{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;AAKA,SAAQ,OAAR,QAAsB,kBAAtB;;;;;;AAOA,OAAO,GAAP,MAAgB,gBAAhB;;;;;AAKA,OAAO,OAAP,MAAoB,oBAApB;;AAEA,OAAO,EAAP,GAAY;AACR,WAAO,OADC;AAER,iBAAa,EAFL;AAGR,eAAW,YAAY;AACnB,gBAAQ,GAAR,CAAY,8BAA8B,KAAK,GAA/C;AACH,KALO;AAMR,eAAW,YAAY;AACnB,gBAAQ,GAAR,CAAY,SAAZ;AACH;AARO,CAAZ;;AAWA,QAAQ,EAAR;;;;;;;;;;;;;;;AAeA,IAAI,OAAJ,CAAY,EAAZ,EAAgB,MAAM;AAClB,OAAG,OAAH,CAAW,GAAG,OAAH,EAAX;AACH,CAFD,EAEG,MAAM,CAAE,CAFX;;AAIA,IAAI,OAAJ,CAAY,EAAZ,EAAgB,MAAM;AAClB,OAAG,OAAH,CAAW,GAAG,OAAH,EAAX;;AAEH,CAHD,EAGG,MAAM,CAAE,CAHX","file":"index-compiled.js","sourcesContent":["/**\n * 一个对象 var ob = observer(obj)(如果是一个多层嵌套对象,则无限递归下去)\n * 给obj设置get set (如果该对象本来就有get\\set 则再包一层)\n * 对象一旦被set, 就调用ob.deps.notice  (deps 里维护了一个watcher队列，可以通过ob.deps.addSub添加watch)\n */\nimport {observe} from './observer/index';\n\n\n/**\n * 管理消息队列\n * 拥有挂载类Dep上的全局唯一对象target\n */\nimport dep from './observer/dep';\n\n/**\n * 消息载体\n */\nimport Watcher from './observer/watcher';\n\nwindow.vm = {\n    \"key\": \"value\",\n    \"_watchers\": [],\n    \"_render\": function () {\n        console.log('_render : call vm data : ' + this.key)\n    },\n    \"_update\": function () {\n        console.log('_update')\n    }\n}\n\nobserve(vm);\n\n/**\n * Watch 内部的函数: 必须要有个对vm的get操作\n * 当生成watcher实例时:\n *  1、把当前watcher作为全局唯一的target, 挂载到Dep类上 (Dep.pushTarget(this))\n *  2、执行handler\n *      hander 必须执行下对vm对象的get操作\n *      因为在get的时候, 如果 Dep.target 存在, 才会把当前watcher实例dep实例的队列里(dep.addSub(this))\n *  3、执行Dep.popTarget, 把Dep类上的唯一target移除\n *  4、当有对vm的set操作的时候, 直接执行dep实例上的watcher队列(dep.notify())\n *\n *\n *  注意: Dep 是消息队列的类, dep是消息队列的实例对象\n */\nnew Watcher(vm, () => {\n    vm._update(vm._render())\n}, () => {})\n\nnew Watcher(vm, () => {\n    vm._update(vm._render())\n    // console.log(\"xx\")\n}, () => {})\n"]}